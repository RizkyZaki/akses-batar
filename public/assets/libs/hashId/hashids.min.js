/**
 * Skipped minification because the original files appears to be already minified.
 * Original file: /npm/hashids@2.3.0/dist/hashids.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("Hashids",[],e):"object"==typeof exports?exports.Hashids=e():t.Hashids=e()}(self,(()=>(()=>{"use strict";var t={d:(e,i)=>{for(var s in i)t.o(i,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:i[s]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{default:()=>g});const i=t=>"bigint"==typeof t||!Number.isNaN(Number(t))&&Math.floor(Number(t))===t,s=t=>"bigint"==typeof t||t>=0&&Number.isSafeInteger(t);function n(t,e){if(0===e.length)return t;let i;const s=[...t];for(let t=s.length-1,n=0,r=0;t>0;t--,n++){n%=e.length,r+=i=e[n].codePointAt(0);const o=(i+n+r)%t,h=s[t],a=s[o];s[o]=h,s[t]=a}return s}const r=(t,e)=>t.reduce(((i,s)=>{const n=e.indexOf(s);if(-1===n)throw new Error(`The provided ID (${t.join("")}) is invalid, as it contains characters that do not exist in the alphabet (${e.join("")})`);if("bigint"==typeof i)return i*BigInt(e.length)+BigInt(n);const r=i*e.length+n;return Number.isSafeInteger(r)?r:(l("Unable to decode the provided string, due to lack of support for BigInt numbers in the current environment"),BigInt(i)*BigInt(e.length)+BigInt(n))}),0),o=/^\+?\d+$/,h=t=>new RegExp(t.map((t=>a(t))).sort(((t,e)=>e.length-t.length)).join("|")),a=t=>t.replace(/[\s#$()*+,.?[\\\]^{|}-]/g,"\\$&"),l=(t="BigInt is not available in this environment")=>{if("function"!=typeof BigInt)throw new TypeError(t)};class g{constructor(t="",e=0,i="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890",s="cfhistuCFHISTU"){if(this.minLength=e,"number"!=typeof e)throw new TypeError(`Hashids: Provided 'minLength' has to be a number (is ${typeof e})`);if("string"!=typeof t)throw new TypeError(`Hashids: Provided 'salt' has to be a string (is ${typeof t})`);if("string"!=typeof i)throw new TypeError(`Hashids: Provided alphabet has to be a string (is ${typeof i})`);const r=Array.from(t),o=Array.from(i),l=Array.from(s);this.salt=r;const g=[...new Set(o)];var p;if(g.length<16)throw new Error(`Hashids: alphabet must contain at least 16 unique characters, provided: ${g.join("")}`);this.alphabet=(p=l,g.filter((t=>!p.includes(t))));const c=(d=g,l.filter((t=>d.includes(t))));var d;let f,u;this.seps=n(c,r),(0===this.seps.length||this.alphabet.length/this.seps.length>3.5)&&(f=Math.ceil(this.alphabet.length/3.5),f>this.seps.length&&(u=f-this.seps.length,this.seps.push(...this.alphabet.slice(0,u)),this.alphabet=this.alphabet.slice(u))),this.alphabet=n(this.alphabet,r);const b=Math.ceil(this.alphabet.length/12);this.alphabet.length<3?(this.guards=this.seps.slice(0,b),this.seps=this.seps.slice(b)):(this.guards=this.alphabet.slice(0,b),this.alphabet=this.alphabet.slice(b)),this.guardsRegExp=h(this.guards),this.sepsRegExp=h(this.seps),this.allowedCharsRegExp=(t=>new RegExp(`^[${t.map((t=>a(t))).sort(((t,e)=>e.length-t.length)).join("")}]+$`))([...this.alphabet,...this.guards,...this.seps])}encode(t,...e){let n=Array.isArray(t)?t:[...null!=t?[t]:[],...e];return 0===n.length?"":(n.every(i)||(n=n.map((t=>"bigint"==typeof t||"number"==typeof t?t:(t=>{if(!o.test(t))return Number.NaN;const e=Number.parseInt(t,10);return Number.isSafeInteger(e)?e:(l("Unable to encode the provided BigInt string without loss of information due to lack of support for BigInt type in the current environment"),BigInt(t))})(String(t))))),n.every(s)?this._encode(n).join(""):"")}decode(t){return t&&"string"==typeof t&&0!==t.length?this._decode(t):[]}encodeHex(t){let e=t;switch(typeof e){case"bigint":e=e.toString(16);break;case"string":if(!/^[\dA-Fa-f]+$/.test(e))return"";break;default:throw new Error(`Hashids: The provided value is neither a string, nor a BigInt (got: ${typeof e})`)}const i=(s=e,12,n=t=>Number.parseInt(`1${t}`,16),Array.from({length:Math.ceil(s.length/12)},((t,e)=>n(s.slice(12*e,12*(e+1))))));var s,n;return this.encode(i)}decodeHex(t){return this.decode(t).map((t=>t.toString(16).slice(1))).join("")}isValidId(t){return this.allowedCharsRegExp.test(t)}_encode(t){let{alphabet:e}=this;const i=t.reduce(((t,e,i)=>t+("bigint"==typeof e?Number(e%BigInt(i+100)):e%(i+100))),0);let s=[e[i%e.length]];const r=[...s],{seps:o}=this,{guards:h}=this;if(t.forEach(((i,h)=>{const a=r.concat(this.salt,e);e=n(e,a);const l=((t,e)=>{const i=[];let s=t;if("bigint"==typeof s){const t=BigInt(e.length);do{i.unshift(e[Number(s%t)]),s/=t}while(s>BigInt(0))}else do{i.unshift(e[s%e.length]),s=Math.floor(s/e.length)}while(s>0);return i})(i,e);if(s.push(...l),h+1<t.length){const t=l[0].codePointAt(0)+h,e="bigint"==typeof i?Number(i%BigInt(t)):i%t;s.push(o[e%o.length])}})),s.length<this.minLength){const t=(i+s[0].codePointAt(0))%h.length;if(s.unshift(h[t]),s.length<this.minLength){const t=(i+s[2].codePointAt(0))%h.length;s.push(h[t])}}const a=Math.floor(e.length/2);for(;s.length<this.minLength;){e=n(e,e),s.unshift(...e.slice(a)),s.push(...e.slice(0,a));const t=s.length-this.minLength;if(t>0){const e=t/2;s=s.slice(e,e+this.minLength)}}return s}_decode(t){if(!this.isValidId(t))throw new Error(`The provided ID (${t}) is invalid, as it contains characters that do not exist in the alphabet (${this.guards.join("")}${this.seps.join("")}${this.alphabet.join("")})`);const e=t.split(this.guardsRegExp),i=e[3===e.length||2===e.length?1:0];if(0===i.length)return[];const s=i[Symbol.iterator]().next().value,o=i.slice(s.length).split(this.sepsRegExp);let h=this.alphabet;const a=[];for(const t of o){const e=n(h,[s,...this.salt,...h].slice(0,h.length));a.push(r(Array.from(t),e)),h=e}return this._encode(a).join("")!==t?[]:a}}return e.default})()));
//# sourceMappingURL=hashids.js.map